"""Pydantic schemas for validating input and DTOs."""
from __future__ import annotations

from typing import List, Optional, Literal

from pydantic import BaseModel, EmailStr, Field, field_validator


class UserCreate(BaseModel):
    """Schema for user registration."""

    username: str = Field(min_length=3, max_length=50)
    email: EmailStr
    password: str = Field(min_length=8)
    role: Literal["teacher", "student"]

    @field_validator("username")
    @classmethod
    def username_valid(cls, v: str) -> str:
        import re

        if not re.fullmatch(r"^[A-Za-z0-9_]{3,50}$", v):
            raise ValueError("Username must be 3-50 chars, alphanumeric or underscore only")
        return v

    @field_validator("password")
    @classmethod
    def password_strength(cls, v: str) -> str:
        import re

        if not re.search(r"[A-Z]", v):
            raise ValueError("Password must include at least one uppercase letter")
        if not re.search(r"[a-z]", v):
            raise ValueError("Password must include at least one lowercase letter")
        if not re.search(r"[0-9]", v):
            raise ValueError("Password must include at least one digit")
        return v


class UserLogin(BaseModel):
    """Schema for user login."""

    username: str
    password: str


class TestCreate(BaseModel):
    """Schema for creating a test."""

    title: str = Field(min_length=5, max_length=255)
    description: Optional[str] = Field(default=None, max_length=1000)
    test_type: Literal["pre", "post"]
    # access_key is auto-generated by server


class QuestionCreate(BaseModel):
    """Schema for creating a question."""

    question_text: str = Field(min_length=10)
    options: List[str] = Field(min_length=4, max_length=4)
    correct_answer: int = Field(ge=0, le=3)
    explanation: str = Field(min_length=5, max_length=1000)
    topic_tag: str
    difficulty: Literal["easy", "medium", "hard"]
    order: int = Field(ge=0)

    @field_validator("options")
    @classmethod
    def options_unique_and_count(cls, v: List[str]) -> List[str]:
        if len(v) != 4:
            raise ValueError("Exactly 4 options are required")
        if len(set([o.strip() for o in v])) != 4:
            raise ValueError("Options must be unique")
        return v
